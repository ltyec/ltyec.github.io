[{"content":"Range 如果想要指定一个集合，其中包含1一直到10的自然数，只需要使用..：\n// 包含1和10 val onetoten = 1..10 // 包含1不包含10 val onetoten = 1..\u0026lt;10 // 如果需要一个递减的集合 val tentoone = 10 downTo 1 同时，也可以修改步长\n// 1,3,5,7,9 val onetoten = 1..10 step 2 If kotlin的判断if非常特殊，可以直接调用：\nif (num in 1..10){  println(\u0026#34;one to ten\u0026#34;) }else if(num in 11..20){  println(\u0026#34;eleven to twenty\u0026#34;) }else{  println(\u0026#34;out of range\u0026#34;) } 同时，也可以将他作为表达式使用：\nprintln(\u0026#34;输出结果是：${if (num in 1..10) \u0026#34;one to ten\u0026#34; else if (num in 11..20) \u0026#34;eleven to twenty\u0026#34; else \u0026#34;out of range\u0026#34;}\u0026#34;) if可以拿来判断什么呢？几乎一切能够用布尔值概括的条件，true就执行，false就不执行\n以下是各种可概括的条件\n1 // true 1 == 1 // true 1 in 1..10 // true 0 // false 1 - 1 // false 5 !in 1..10 // false \u0026#34;0\u0026#34; // true When when函数的功能与switch十分近似,同样地，他也属于表达式，所以也可以有两种用法\n// 直接调用 when (input) {  1 -\u0026gt; println(\u0026#34;输入1\u0026#34;)  2 -\u0026gt; println(\u0026#34;输入2\u0026#34;)  3 -\u0026gt; println(\u0026#34;输入3\u0026#34;)  else -\u0026gt; {  println(\u0026#34;输入超过限制\u0026#34;)  } } // 作为表达式赋值 var output = when (input) {  1 -\u0026gt; \u0026#34;输入1\u0026#34;  2 -\u0026gt; \u0026#34;输入2\u0026#34;  3 -\u0026gt; \u0026#34;输入3\u0026#34;  else -\u0026gt; {  \u0026#34;输入超过限制\u0026#34;  } } println(output) when (input) {1 -\u0026gt; }与if (input == 1)是一个意思\n同样，when也可以使用跟if一样的判断条件：\nvar output = when (num) {  in 1..10 -\u0026gt; \u0026#34;tier1\u0026#34;  in 11..20 -\u0026gt; \u0026#34;tier2\u0026#34;  in 21..30 -\u0026gt; \u0026#34;tier3\u0026#34;  else -\u0026gt; {  \u0026#34;Unexcepted num\u0026#34;  } } println(output) 如果我们把括号给去掉会出现语法错误吗？答案是不会，我们还可以获得两个等价的表达\nvar tf = when (true) {} var tf = when {} ","date":"2023-10-12T00:00:00Z","image":"https://ltyec.com/post/kotlin-3/rasp_huf05bd74a22f9ad932fc426ad72ecc99a_73708_120x120_fill_q75_box_smart1.jpg","permalink":"https://ltyec.com/post/kotlin-3/","title":"Kotlin学习笔记-3"},{"content":"入门知识 kt包 在kotlin中，存在包的概念，一个项目可以有很多包，他们是可以独立运作的\n在IDEA中，如果创建了包，则会在kt文件顶部直接声明\n// 该文件隶属于包tenshi.first.demo package tenshi.first.demo 只要在同一个包中，kt文件就几乎不受目录结构影响\n导入类 导入属于十分常见的方法，在文件顶部声明\n// 导入tenshi.security中的所有类 import tenshi.security.* main() 函数 kt程序的入口是main函数\nfun main(){  print(\u0026#34;Hello \u0026#34;)  print(\u0026#34;World!\u0026#34;)  println(\u0026#34;Hello World!\u0026#34;) } 输出结果为下：\nHello World! Hello World! 这是因为，print函数不会换行\n而println（print\\n）函数则是将自己作为独立的一行输出\n注释 kotlin中的注释分为行注释与块注释，具体写法如下：\n// 我是行注释 /* 我是块 注释 */ 块注释支持嵌套\n/* 我是块注释开头 /* 我属于块注释的嵌套 */ 块注释的尾巴在这里！ */  具体更多的函数实现将会在以后的笔记中呈现，现在暂时略过\n 数据类型 Kotlin有以下常见的数据类型：\nString 字符串 Char 单字符 Boolean 布尔值（t/f） Int 整数 Double 双精度小数 Float 单精度小数 List 集合 Set 无重复的集合 Map 键值对集合 Unit 无输出函数对象，类似于java的void Nothing 多用于抛异常，永不输出的函数对象 ...... 看似以上全是引用类型，但当其编译再转入jvm时，就会变成基本类型使用\nvar与val var定义的是可变变量 而val定义的是只读变量\n请看代码：\n// 将\u0026#34;v1\u0026#34;这个字符串赋值给变量v1 var v1: String = \u0026#34;v1\u0026#34; // 将\u0026#34;v2\u0026#34;这个字符串赋值给只读变量v2 val v2: String = \u0026#34;v2\u0026#34; 由于Kotlin自带类型推断，于是我们可以将其写为这个格式：\n// 将\u0026#34;v1\u0026#34;赋值给变量v1，编译器自动将v1推断为String var v1 = \u0026#34;v1\u0026#34; // 将\u0026#34;v2\u0026#34;赋值给只读变量v2，编译器自动将v2推断为String val v2 = \u0026#34;v2\u0026#34;  只读变量与编译时参数不同，只读变量如果属于List类型，其中的元素依然可以更改，但元素的数量以及类型均为只读\n 定义编译时参数的实现如下\nconst val v1: String = \u0026#34;v1\u0026#34; // 当然，这同样支持类型推断 const val v1 = \u0026#34;v1\u0026#34; 编译时常量的定义实现不能写在函数内，不适用于局部变量\n","date":"2023-10-11T00:00:00Z","image":"https://ltyec.com/post/kotlin-1/take_hu65c73d4917ebe70c6646dd2cb143f70c_50501_120x120_fill_box_smart1_3.png","permalink":"https://ltyec.com/post/kotlin-1/","title":"Kotlin学习笔记-1"},{"content":"基础函数定义 kotlin一般定义函数的方法如下\n/*定义一个公有函数为f1，第一个传入数据定义为v1， v1是String类型，函数返回字符串所以填写String类型*/ public fun f1(v1: String): String{  // 返回v1加字符串\u0026#34; World!\u0026#34;  return \u0026#34;$v1World!\u0026#34; }  这其中有一点十分有趣，kotlin支持在字符串中直接$变量名，前提是后面没有紧跟着的字符，不然就需要使用${变量名}来解决\n 那没有返回的函数呢？如何填写类型？\n这就引出了Kotlin的特殊类型Unit，它可以在没有输出的情况下依然使函数返回一个对象\n// 将返回类型换成Unit，可以省略\u0026#34;: Unit\u0026#34;不写，编译器看得懂 public fun f1(v1: String): Unit{  // 打印v1加字符串\u0026#34; World!\u0026#34;  println(\u0026#34;$v1World!\u0026#34;)  // 返回Unit，这句话也可以省略不写，编译器也看得懂  return Unit }  请注意！第一个Unit指代的是返回类型，而第二个Unit则是一个具体对象，虽然同名，但绝不一样\n 同样，我们也可以定义私有函数：\n// 定义一个私有函数为f2，传入字符串定义为v2，函数返回String类型 private fun f1(v1: String): String{  // 返回v1加字符串\u0026#34; World!\u0026#34;  return \u0026#34;$v1World!\u0026#34; } 在继承方式中，可以直接忽略public不写，这样子我们就能获得两个等价的表达\n传递变量 变量的传递十分简单，只需要在调用时传入即可\n// 程序入口点 fun main(){  val a = \u0026#34;1\u0026#34;  val b = \u0026#34;2\u0026#34;  val c = \u0026#34;3\u0026#34;  // 将变量a,b,c导入函数push2，再打印返回的字符串  println(push2(a,b,c)) }  // 定义一个公有函数push2，传入字符串定义为x,y,z fun push2(x: String,y: String,z: String): String{  // 返回字符串  return \u0026#34;倒数${z+y+x}\u0026#34; } 运行的结果就是\n倒数321 来尝试一次吧！ 让我们写一个完整的一段代码\n// 声明所属包 package tenshi.first.demo  // 定义编译时常量v const val v = \u0026#34;Hello\u0026#34;  // 程序入口点 fun main(){  // 将变量v导入函数hello  hello(v) }  // 定义一个公有函数hello，传入字符串定义为v1 fun hello(v1: String){  // 打印v1加字符串\u0026#34; World!\u0026#34;  println(\u0026#34;$v1World!\u0026#34;) } 输出结果就是喜闻乐见的\nHello World! ","date":"2023-10-11T00:00:00Z","image":"https://ltyec.com/post/kotlin-2/hlzj_hub410b0d2ec15149bcfdf744129fd2852_1546586_120x120_fill_box_smart1_3.png","permalink":"https://ltyec.com/post/kotlin-2/","title":"Kotlin学习笔记-2"}]